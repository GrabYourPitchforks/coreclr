// Licensed to the .NET Foundation under one or more agreements.
// The .NET Foundation licenses this file to you under the MIT license.
// See the LICENSE file in the project root for more information.

using System;
using System.Buffers.Binary;
using System.Collections.Generic;
using System.Diagnostics;
using System.Globalization;
using System.IO;

namespace GenUnicodeProp
{
    internal static class Program
    {
        private static void Main(string[] args)
        {
            Verbose = false;
            // TODO: parse args

            // Create a 12:4:4 table for Unicode code point properties
            // (casing data, bidi category, Unicode category).  The value is 1 byte to indicate Unicode category
            // Make sure to put the default value into the slot 0 in $codepointPropertiesValueTable
            var codepointPropertiesIndexTable = new DataTable();
            // Create a 12:4:4 table for decimal digit value/digit value/numeric value
            var numericIndexTable = new DataTable();
            // Create a flat table for code point's properties
            var codepointPropertiesValueTable = new FlatDataTable<CodepointProperties>(new CodepointProperties(), null); // callback not specified
            // Create a flat table.
            // GetNumericValueBytes() is the callback used to generate the bytes of each item.
            var numericValueTable = new FlatDataTable<string>("-1", GetNumericValueBytes);
            // Create a flat table for digit values
            // GetDigitValueBytes() is the callback used to generate the bytes of each item.
            var digitValueTable = new FlatDataTable<string>("255,255", GetDigitValueBytes);

            // Add a default item into the codepoint properties table.  This will be the item 0 in the category value table.
            GetCodepointPropertiesItem(codepointPropertiesValueTable, new CodepointProperties());
            NumberValues.Add("-1,255,255", 0);
            numericValueTable.AddData(0, "-1");
            digitValueTable.AddData(0, "255,255");

            ReadPropsList();
            ReadCaseFolding();
            ReadSourceFile("UnicodeData.txt", codepointPropertiesIndexTable, codepointPropertiesValueTable, numericIndexTable, numericValueTable, digitValueTable);

            codepointPropertiesIndexTable.GenerateTable(nameof(codepointPropertiesIndexTable), 5, 4);
            //categoriesIndexTable.CalculateTableVariants();
            numericIndexTable.GenerateTable(nameof(numericIndexTable), 4, 4, cutOff: true);
            //numericIndexTable.CalculateTableVariants(cutOff: true);

            // generate the data C# source
            using (StreamWriter file = File.CreateText(SOURCE_NAME))
            {
                file.Write("// Licensed to the .NET Foundation under one or more agreements.\n");
                file.Write("// The .NET Foundation licenses this file to you under the MIT license.\n");
                file.Write("// See the LICENSE file in the project root for more information.\n\n");

                file.Write("namespace System.Globalization\n");
                file.Write("{\n");
                file.Write("    public static partial class CharUnicodeInfo\n    {\n");

                file.Write("        // THE FOLLOWING DATA IS AUTO GENERATED BY GenUnicodeProp program UNDER THE TOOLS FOLDER\n");
                file.Write("        // PLEASE DON'T MODIFY BY HAND\n\n\n");

                file.Write("        // 11:5:4 index table of the Unicode code point properties data.");
                PrintSourceIndexArray("CodePointPropertiesLevel1Index", codepointPropertiesIndexTable, file);

                PrintValueArray("CategoriesValue", codepointPropertiesValueTable, GetCategoryValueBytes, file);
                PrintValueArray("SimpleCaseFoldValue", codepointPropertiesValueTable, GetSimpleCaseFoldBytes, file);
                PrintValueArray("SimpleLowerValue", codepointPropertiesValueTable, GetSimpleLowerCaseBytes, file);
                PrintValueArray("SimpleTitleValue", codepointPropertiesValueTable, GetSimpleTitleCaseBytes, file);
                PrintValueArray("SimpleUpperValue", codepointPropertiesValueTable, GetSimpleUpperCaseBytes, file);

                file.Write("\n        // 12:4:4 index table of the Unicode numeric data.");
                PrintSourceIndexArray("NumericLevel1Index", numericIndexTable, file);

                file.Write("\n        // Every item contains the value for numeric value.");
                PrintValueArray("NumericValues", numericValueTable, file);

                PrintValueArray("DigitValues", digitValueTable, file);

                file.Write("\n    }\n}");
            }
        }

        private static bool Verbose;

        private const string SOURCE_NAME = "CharUnicodeInfoData.cs";

        private static readonly Dictionary<string, UnicodeCategory> UnicodeCategoryMap = new Dictionary<string, UnicodeCategory>
        {
            ["Lu"] = UnicodeCategory.UppercaseLetter,
            ["Ll"] = UnicodeCategory.LowercaseLetter,
            ["Lt"] = UnicodeCategory.TitlecaseLetter,
            ["Lm"] = UnicodeCategory.ModifierLetter,
            ["Lo"] = UnicodeCategory.OtherLetter,
            ["Mn"] = UnicodeCategory.NonSpacingMark,
            ["Mc"] = UnicodeCategory.SpacingCombiningMark,
            ["Me"] = UnicodeCategory.EnclosingMark,
            ["Nd"] = UnicodeCategory.DecimalDigitNumber,
            ["Nl"] = UnicodeCategory.LetterNumber,
            ["No"] = UnicodeCategory.OtherNumber,
            ["Zs"] = UnicodeCategory.SpaceSeparator,
            ["Zl"] = UnicodeCategory.LineSeparator,
            ["Zp"] = UnicodeCategory.ParagraphSeparator,
            ["Cc"] = UnicodeCategory.Control,
            ["Cf"] = UnicodeCategory.Format,
            ["Cs"] = UnicodeCategory.Surrogate,
            ["Co"] = UnicodeCategory.PrivateUse,
            ["Pc"] = UnicodeCategory.ConnectorPunctuation,
            ["Pd"] = UnicodeCategory.DashPunctuation,
            ["Ps"] = UnicodeCategory.OpenPunctuation,
            ["Pe"] = UnicodeCategory.ClosePunctuation,
            ["Pi"] = UnicodeCategory.InitialQuotePunctuation,
            ["Pf"] = UnicodeCategory.FinalQuotePunctuation,
            ["Po"] = UnicodeCategory.OtherPunctuation,
            ["Sm"] = UnicodeCategory.MathSymbol,
            ["Sc"] = UnicodeCategory.CurrencySymbol,
            ["Sk"] = UnicodeCategory.ModifierSymbol,
            ["So"] = UnicodeCategory.OtherSymbol,
            ["Cn"] = UnicodeCategory.OtherNotAssigned,
        };

        // Store the current combinations of categories (Unicode category, BiDi category)
        private static readonly Dictionary<string, byte> CategoryValues = new Dictionary<string, byte>();

        // Store the current combinations of categories & properties for a code point
        private static readonly Dictionary<CodepointProperties, byte> CodepointPropertiesValues = new Dictionary<CodepointProperties, byte>();

        private static readonly Dictionary<string, byte> NumberValues = new Dictionary<string, byte>();

        // List of code points which represent white space.
        // See: https://unicode.org/cldr/utility/list-unicodeset.jsp?a=[:whitespace:]
        private static readonly HashSet<uint> WhiteSpaceCodePoints = new HashSet<uint>();

        // Contains simple (single scalar to single scalar) case folding data.
        // Key = code point, Value = offset to add to code point in order to produce case fold map
        // Example: 'A' (U+0041) case fold maps to 'a' (U+0061), so map['A'] = (0x0061 - 0x0041).
        // If a scalar is not found in this map, it case folds to itself.
        private static readonly Dictionary<uint, int> SimpleCaseFoldingMap = new Dictionary<uint, int>();

        /// <summary>
        /// Check if we need to add a new item in the codepointPropertiesTable.  If yes,
        /// add one item and return the new item number.  Otherwise, return the existing
        /// item number.
        /// </summary>
        /// <param name="codepointPropertiesTable"></param>
        /// <param name="codepointProperties">The properties for this specific code point,
        /// as constructed from CaseFolding.txt, PropList.txt, and UnicodeData.txt.</param>
        /// <returns>The item number in the CodePointValues</returns>
        private static byte GetCodepointPropertiesItem(FlatDataTable<CodepointProperties> codepointPropertiesTable, CodepointProperties codepointProperties)
        {
            if (!CodepointPropertiesValues.TryGetValue(codepointProperties, out var categoryItem))
            {
                // This combination of properties has not shown up before.
                if (CodepointPropertiesValues.Count >= 255)
                    throw new InvalidOperationException("The possible number of values exceeds 255.");

                // Get the current element count of the hash table and update the category item
                categoryItem = (byte)CodepointPropertiesValues.Count;
                CodepointPropertiesValues.Add(codepointProperties, categoryItem);
                // Add the category values.
                codepointPropertiesTable.AddData(categoryItem, codepointProperties);
            }
            return categoryItem;
        }

        /// <summary>
        /// Read CaseFolding.txt and populate the "simple case folding" map.
        /// </summary>
        private static void ReadCaseFolding()
        {
            string[] allEntriesInCaseFoldingFile = File.ReadAllLines("CaseFolding.txt");

            foreach (string entry in allEntriesInCaseFoldingFile)
            {
                // We're looking for entries in the form:
                // UUUU; Status; YYYY; # <comment>
                // Where UUUU = <from>, YYYY = <to>, and Status = 'C' or 'S'

                string[] fields = entry.Split('#');
                if (fields.Length < 2)
                {
                    continue; // line wasn't in the proper format
                }

                fields = fields[0].Split(';');
                if (fields.Length != 4)
                {
                    continue; // line wasn't in the proper format
                }

                char status = fields[1].Trim()[0];
                if (status != 'C' && status != 'S')
                {
                    continue; // don't care about anything other than Common or Simple
                }

                uint codePointFrom = uint.Parse(fields[0], NumberStyles.HexNumber, CultureInfo.InvariantCulture);
                uint codePointTo = uint.Parse(fields[2], NumberStyles.HexNumber, CultureInfo.InvariantCulture);

                SimpleCaseFoldingMap[codePointFrom] = (int)(codePointTo - codePointFrom);
            }
        }

        /// <summary>
        /// Read PropList.txt and populate the "white space code points" set.
        /// </summary>
        private static void ReadPropsList()
        {
            string[] allEntriesInPropsFile = File.ReadAllLines("PropList.txt");

            foreach (string entry in allEntriesInPropsFile)
            {
                // We're looking for entries in the form:
                // UUUU[..YYYY] ; White_Space # <comment>

                string[] fields = entry.Split('#');
                if (fields.Length < 2)
                {
                    continue; // line wasn't in the proper format
                }

                fields = fields[0].Split(';');
                if (fields.Length != 2)
                {
                    continue; // line wasn't in the proper format
                }

                if (fields[1].Trim() != "White_Space")
                {
                    continue; // We don't care about any property other than "White_Space"
                }

                string[] rangeBoundaries = fields[0].Split("..");

                Debug.Assert(rangeBoundaries.Length >= 1 && rangeBoundaries.Length <= 2);

                uint firstCodePointInRange = uint.Parse(rangeBoundaries[0], NumberStyles.HexNumber, CultureInfo.InvariantCulture);
                uint lastCodePointInRange = firstCodePointInRange;

                if (rangeBoundaries.Length == 2)
                {
                    lastCodePointInRange = uint.Parse(rangeBoundaries[1], NumberStyles.HexNumber, CultureInfo.InvariantCulture);
                }

                for (uint i = firstCodePointInRange; i <= lastCodePointInRange; i++)
                {
                    WhiteSpaceCodePoints.Add(i); // this code point should be treated as white space
                }
            }
        }

        /// <summary>
        /// Read UnicodeData.txt and call DataTable.AddData() to add values for codepoints.
        /// </summary>
        private static void ReadSourceFile(string sourceFileName, DataTable codePointPropertiesIndexTable, FlatDataTable<CodepointProperties> codepointPropertiesTable, DataTable numericIndexTable, FlatDataTable<string> numericValueTable, FlatDataTable<string> digitValueTable)
        {
            var lineCount = 0; // The line count
            var codePointCount = 0; // The count of the total characters in the file.

            Console.Write($"Read {sourceFileName}");

            // Field	Name in UnicodeData.txt
            // 0	Code value
            // 1	Character name
            // 2	General Category
            //
            // 3	Canonical Combining Classes
            // 4	Bidirectional Category
            // 5	Character Decomposition Mapping
            // 6	Decimal digit value
            // 7	Digit value
            // 8	Numeric value
            // 9	Mirrored
            // 10	Unicode 1.0 Name
            // 11	10646 comment field
            // 12	Uppercase Mapping
            // 13	Lowercase Mapping
            // 14	Titlecase Mapping

            using (StreamReader sourceFile = File.OpenText(sourceFileName))
                while (sourceFile.ReadLine() is string line)
                {
                    var fields = line.Split(';');
                    var code = uint.Parse(fields[0], NumberStyles.HexNumber);
                    var comments = fields[1];
                    var category = fields[2];

                    var bidiCategory = fields[4];
                    var decimalDigitValue = fields[6];
                    var digitValue = fields[7];
                    var numericValue = fields[8];

                    var codeUpperCase = fields[12];
                    var codeLowerCase = fields[13];
                    var codeTitleCase = fields[14];

                    var allCategoryValues = category + "," + bidiCategory;
                    var allDigitValue = (decimalDigitValue == "" ? "255" : decimalDigitValue) + "," + (digitValue == "" ? "255" : digitValue);
                    var allNumValues = numericValue == "" ? "-1" : numericValue;
                    var allValues = allNumValues + "," + allDigitValue;

                    if (Verbose)
                    {
                        Console.WriteLine($"[{code:X4}]- Cat: [{category}], BiDi Category: [{bidiCategory}], Numeric: [{numericValue}], Comments: [{comments}]");
                    }

                    if (!NumberValues.TryGetValue(allValues, out var numItem))
                    {
                        if (NumberValues.Count >= 255)
                            throw new InvalidOperationException("The possible number of values exceeds 255.");
                        // Get the current element count of the hash table
                        numItem = (byte)NumberValues.Count;
                        NumberValues[allValues] = numItem;
                        numericValueTable.AddData(numItem, allNumValues);
                        digitValueTable.AddData(numItem, allDigitValue);
                    }

                    // Fill in this code point's properties from the mapping we've been building so far

                    var codepointProperties = new CodepointProperties()
                    {
                        Category = UnicodeCategoryMap[category],
                        IsWhiteSpace = WhiteSpaceCodePoints.Contains(code),
                        BidiClass = NormalizeBidiClass(bidiCategory)
                    };

                    if (SimpleCaseFoldingMap.TryGetValue(code, out int caseFoldOffset))
                    {
                        codepointProperties.OffsetToSimpleFoldCase = caseFoldOffset;
                    }

                    if (uint.TryParse(codeUpperCase, NumberStyles.HexNumber, CultureInfo.InvariantCulture, out uint asUpper))
                    {
                        codepointProperties.OffsetToSimpleUpperCase = (int)(asUpper - code);
                    }

                    if (uint.TryParse(codeLowerCase, NumberStyles.HexNumber, CultureInfo.InvariantCulture, out uint asLower))
                    {
                        codepointProperties.OffsetToSimpleLowerCase = (int)(asLower - code);
                    }

                    if (uint.TryParse(codeTitleCase, NumberStyles.HexNumber, CultureInfo.InvariantCulture, out uint asTitle))
                    {
                        codepointProperties.OffsetToSimpleTitleCase = (int)(asTitle - code);
                    }

                    var codepointPropertiesItem = GetCodepointPropertiesItem(codepointPropertiesTable, codepointProperties);

                    if (comments[0] == '<' && comments.EndsWith(", First>", StringComparison.Ordinal))
                    {
                        if (Verbose)
                        {
                            Console.WriteLine($"Range start: {code:X4} [{category}] [{comments}]");
                        }

                        // Read the next line to get the end of the range.
                        var endFields = sourceFile.ReadLine().Split(';');
                        var codeEndRange = uint.Parse(endFields[0], NumberStyles.HexNumber);
                        var valueEndRange = endFields[2];
                        var commentsEndRange = endFields[1];

                        if (Verbose)
                        {
                            Console.WriteLine($"Range   end: {codeEndRange:X4} [{valueEndRange}] [{commentsEndRange}]");
                        }

                        if (category != valueEndRange)
                        {
                            Console.WriteLine("Different categories in the beginning of the range and the end of the range");
                            Environment.Exit(1);
                        }

                        // Add data for a range of code points
                        for (var i = code; i <= codeEndRange; i++)
                        {
                            codePointPropertiesIndexTable.AddData(i, codepointPropertiesItem);
                            numericIndexTable.AddData(i, numItem);
                            codePointCount++;
                            if (Verbose)
                            {
                                Console.WriteLine($"Read: {i:X8} [{allCategoryValues}]");
                            }
                        }
                    }
                    else
                    {
                        // Add data for a single code point.
                        codePointPropertiesIndexTable.AddData(code, codepointPropertiesItem);
                        numericIndexTable.AddData(code, numItem);
                        codePointCount++;
                        if (Verbose)
                        {
                            Console.WriteLine($"Read: {code:X8} [{allCategoryValues}]");
                        }
                    }
                    lineCount++;
                    if (lineCount % 256 == 0)
                    {
                        Console.Write('.');
                    }
                }

            Console.WriteLine();
            Console.WriteLine();
            Console.WriteLine($"    Total lines in the file: {lineCount}");
            Console.WriteLine($"    Total characters: {codePointCount}");

            var allValueCount = CategoryValues.Count;
            Console.WriteLine($"    Total possible categories values: {allValueCount + 1}.  Maximum allowed: 256");

            allValueCount = NumberValues.Count;
            Console.WriteLine($"    Total possible number values: {allValueCount + 1}.  Maximum allowed: 256");
            Console.WriteLine($"    Finish reading {sourceFileName}.");
        }

        private static byte[] GetCategoryValueBytes(CodepointProperties properties)
        {
            // We use a single byte to represent the tuple (isWhitespace, bidiDirection, unicodeCategory):
            // +---+---+---+-------+
            // | W | R | L |  CAT  |
            // +---+---+---+-------+
            //   ^   ^   ^    ^----- 5 bits, UnicodeCategory
            //   |   |   `---------- 1 bit , is bidi left-to-right
            //   |   `-------------- 1 bit , is bidi right-to-left
            //   `------------------ 1 bit , is whitespace

            int finalValue = (Convert.ToInt32(properties.IsWhiteSpace) << 7)
                | ((int)properties.BidiClass) << 5
                | (int)properties.Category;

            return new byte[] { (byte)finalValue };
        }

        private static byte[] GetSimpleCaseFoldBytes(CodepointProperties properties)
        {
            byte[] retVal = new byte[sizeof(int)];
            BinaryPrimitives.WriteInt32LittleEndian(retVal, properties.OffsetToSimpleFoldCase);
            return retVal;
        }

        private static byte[] GetSimpleLowerCaseBytes(CodepointProperties properties)
        {
            byte[] retVal = new byte[sizeof(int)];
            BinaryPrimitives.WriteInt32LittleEndian(retVal, properties.OffsetToSimpleLowerCase);
            return retVal;
        }

        private static byte[] GetSimpleTitleCaseBytes(CodepointProperties properties)
        {
            byte[] retVal = new byte[sizeof(int)];
            BinaryPrimitives.WriteInt32LittleEndian(retVal, properties.OffsetToSimpleTitleCase);
            return retVal;
        }

        private static byte[] GetSimpleUpperCaseBytes(CodepointProperties properties)
        {
            byte[] retVal = new byte[sizeof(int)];
            BinaryPrimitives.WriteInt32LittleEndian(retVal, properties.OffsetToSimpleUpperCase);
            return retVal;
        }

        private static byte[] GetNumericValueBytes(string value)
        {
            double d;
            var i = value.IndexOf('/');
            if (i < 0)
                d = double.Parse(value, CultureInfo.InvariantCulture);
            else
                d = double.Parse(value.Substring(0, i), CultureInfo.InvariantCulture) / double.Parse(value.Substring(i + 1), CultureInfo.InvariantCulture);
            return BitConverter.GetBytes(d);
        }

        private static byte[] GetDigitValueBytes(string value)
        {
            if (Verbose)
                Console.WriteLine($"[{value}]");

            var values = value.Split(',');
            var decimalDigitValue = values[0];
            var digitValue = values[1];

            return new[] { byte.Parse(decimalDigitValue), byte.Parse(digitValue) };
        }

        private static RestrictedBidiClass NormalizeBidiClass(string bidiClass)
        {
            switch (bidiClass)
            {
                case "L":
                    return RestrictedBidiClass.LeftToRight;

                case "R":
                case "AL":
                    return RestrictedBidiClass.RightToLeft;

                default:
                    return RestrictedBidiClass.Other;
            }
        }

        private static void PrintSourceIndexArray(string tableName, DataTable d, StreamWriter file)
        {
            Console.WriteLine("    ******************************** .");

            var levels = d.GetBytes();

            PrintByteArray(tableName, file, levels[0]);
            PrintByteArray(tableName.Replace('1', '2'), file, levels[1]);
            PrintByteArray(tableName.Replace('1', '3'), file, levels[2]);
        }

        private static void PrintValueArray<T>(string tableName, FlatDataTable<T> d, StreamWriter file)
        {
            Console.WriteLine("    ******************************** .");
            PrintByteArray(tableName, file, d.GetBytesFlat());
        }

        private static void PrintValueArray<T>(string tableName, FlatDataTable<T> d, Func<T, byte[]> getValueBytesCallback, StreamWriter file)
        {
            Console.WriteLine("    ******************************** .");
            PrintByteArray(tableName, file, d.GetBytesFlat(getValueBytesCallback));
        }

        private static void PrintByteArray(string tableName, StreamWriter file, byte[] str)
        {
            file.Write("\n        private static ReadOnlySpan<byte> " + tableName + " => new byte[" + str.Length + "]\n        {\n");
            file.Write("            0x{0:x2}", str[0]);
            for (var i = 1; i < str.Length; i++)
            {
                file.Write(i % 16 == 0 ? ",\n            " : ", ");
                file.Write("0x{0:x2}", str[i]);
            }
            file.Write("\n        };\n");
        }

        private class CodepointProperties : IEquatable<CodepointProperties>
        {
            public UnicodeCategory Category = UnicodeCategory.OtherNotAssigned;
            public RestrictedBidiClass BidiClass;
            public bool IsWhiteSpace;
            public int OffsetToSimpleUpperCase;
            public int OffsetToSimpleLowerCase;
            public int OffsetToSimpleTitleCase;
            public int OffsetToSimpleFoldCase;

            public override bool Equals(object obj) => this.Equals(obj as CodepointProperties);

            public bool Equals(CodepointProperties other)
            {
                return other is object
                    && this.Category == other.Category
                    && this.BidiClass == other.BidiClass
                    && this.IsWhiteSpace == other.IsWhiteSpace
                    && this.OffsetToSimpleUpperCase == other.OffsetToSimpleUpperCase
                    && this.OffsetToSimpleLowerCase == other.OffsetToSimpleLowerCase
                    && this.OffsetToSimpleTitleCase == other.OffsetToSimpleTitleCase
                    && this.OffsetToSimpleFoldCase == other.OffsetToSimpleFoldCase;
            }

            public override int GetHashCode()
            {
                return HashCode.Combine(Category, BidiClass, IsWhiteSpace, OffsetToSimpleUpperCase, OffsetToSimpleLowerCase, OffsetToSimpleTitleCase, OffsetToSimpleFoldCase);
            }
        }

        private enum RestrictedBidiClass
        {
            /// <summary>
            /// This code point has a bidi class other than "L", "AL", or "R".
            /// </summary>
            Other = 0,

            /// <summary>
            /// This code point has strong left-to-right ordering (bidi class "L").
            /// </summary>
            LeftToRight = 1,

            /// <summary>
            /// This code point has strong right-to-left ordering (bidi class "AL" or "R").
            /// </summary>
            RightToLeft = 2
        }
    }
}
